#!/usr/bin/env bash

rclone_run(){
    local result
    result=$(rclone_exec "${@}")
    rclone_exit_code ${?}
    log I "$(rclone_print_json "${result}")"
}

rclone_print_json(){
    if echo "${@}" | jq -e > /dev/null 2>&1; then
        echo "${@}" | jq -r
    else
        echo "${@}"
    fi
}

rclone_exec(){
    local flags result exit_code

    readarray -t <<<"${@}"
    flags=("${MAPFILE[@]}")
    #echo "length: ${#flags[@]}"
    #for flag in "${flags[@]}"; do
    #    echo "[${flag}]"
    #done

    result=$(${RCLONE}  ${RCLONE_FLAGS_DEFAULT[@]} "${flags[@]}")
    exit_code=${?}
    echo "${result}"
    return ${exit_code}

    ## 0 LOG_EMERG system is unusable
    ## 1 LOG_ALERT action must be taken immediately
    ## 2 LOG_CRIT critical conditions
    ## 3 LOG_ERR error conditions
    ## 4 LOG_WARNING warning conditions
    ## 5 LOG_NOTICE normal, but significant, condition
    ## 6 LOG_INFO informational message
    ## 7 LOG_DEBUG debug-level message
}

rclone_exit_code(){
    local msg
    case "${1}" in
        0) msg="Success" ;;
        1) msg="Syntax or usage error" ;;
        2) msg="Error not otherwise categorised" ;;
        3) msg="Directory not found" ;;
        4) msg="File not found" ;;
        5) msg="Temporary error" ;;
        6) msg="Less serious errors" ;;
        7) msg="Fatal error" ;;
        8) msg="Transfer exceeded" ;;
        9) msg="Operation successful, but no files transferred" ;;
        *) msg="Unkown exit code : ${1}" ;;
    esac
    msg="Rclone exit code : ${1} (${msg})"
    if (( ${1} > 0 )); then
        log E "${msg}"
    else
        log D "${msg}"
    fi
}

rclone_flags_rc(){
    local flags
    flags=("rc" "${@}" "${RCLONE_FLAGS_RC[@]}")
    for flag in "${flags[@]}"; do
        echo "${flag}"
    done
}

rclone_rc_mount(){
    local flags fs mountpoint vfsopt mountopt tmp_fs custom_vfsopt custom_mountopt
    fs="${1}"
    mountpoint="${2}"
    tmp_fs=${fs%%:*}
    tmp_fs="${tmp_fs//-/_}"
    custom_vfsopt="RCLONE_RC_MOUNT_FLAGS_VFSOPT_${tmp_fs}"
    custom_vfsopt="${custom_vfsopt^^}"
    [[ ! -z "${!custom_vfsopt}" ]] && vfsopt="${!custom_vfsopt}" || vfsopt="${RCLONE_RC_MOUNT_FLAGS_VFSOPT}"
    custom_mountopt="RCLONE_RC_MOUNT_FLAGS_MOUNTOPT_${tmp_fs}"
    custom_mountopt="${custom_mountopt^^}"
    [[ ! -z "${!custom_mountopt}" ]] && mountopt="${!custom_mountopt}" || mountopt="${RCLONE_RC_MOUNT_FLAGS_MOUNTOPT}"
    if [[ ! -e "${mountpoint}" ]]; then
        log I "Make the mount folder: ${mountpoint}"
        mkdir -p "${mountpoint}"
    fi
    if [[ -e "${mountpoint}" ]]; then
        flags=("mount/mount" "fs=${fs}" "mountPoint=${mountpoint}" "mountOpt=${mountopt}" "vfsOpt=${vfsopt}")
        printf "$(rclone_exec "$(rclone_flags_rc "${flags[@]}")")"
    else
        log E "The mount point is not exists: ${mountpoint}"
    fi
}

rclone_rc_unmount(){
    local flags mountpoint
    mountpoint="${1}"
    case "${mountpoint}" in
        "all")
            flags="mount/unmountall"
            ;;
        *)
            flags=("mount/unmount" "mountPoint=${mountpoint}")
            ;;
    esac
    printf "$(rclone_exec "$(rclone_flags_rc "${flags[@]}")")"
}

rclone_flags_rc_vfs_refresh() {
    local flags counter remote dirs
    remote=${1}
    shift 1
    flags=("vfs/refresh" "fs=${remote}" "recursive=true" "--fast-list")
    counter=1
    for dir in "${@}"; do
        flags+=("dir${counter}=${dir}")
        (( counter++ ))
    done
    #flags="vfs/refresh|fs=${remote}:|recursive=true|--fast-list"
    #IFS="|" read -r -a dirs <<< "${@}"
    #counter=1
    #for dir in "${dirs[@]}"; do
    #    flags+="|dir${counter}=${dir}"
    #    (( counter++ ))
    #done
    echo "$(rclone_flags_rc "${flags[@]}")"
}

rclone_rc_job_list(){
    printf "$(rclone_exec "$(rclone_flags_rc job/list)")"
}

rclone_rc_job_status(){
    printf "$(rclone_exec "$(rclone_flags_rc "job/status" "jobid=${1}")")"
}

rclone_rc_job_stop(){
    local result
    # it returns {}
    result="$(rclone_exec "$(rclone_flags_rc "job/stop" "jobid=${1}")")"
}

rclone_rc_vfs_stats(){
    printf "$(rclone_exec "$(rclone_flags_rc "vfs/stats" "fs=${1}")")"
}

rclone_rc_job_list_detailed(){
    local status start_time elapsed_hour
    while read jobid; do
        status="$(rclone_rc_job_status ${jobid})"
        case "${1}" in
            "not-finished"|"not-finished-old"|"stop-old")
                [[ "$(printf "${status}" | jq '.finished')" == "true" ]] && continue
                case "${1}" in
                    *"-old")
                        start_time=$(printf "${status}" | jq -r '.startTime')
                        [[ ${start_time} ]] || continue
                        elapsed_hour=$(printf "scale=0; ( $(date +%s) - $(date --date=${start_time} +%s) ) / 3600" | bc)
                        if [[ ${elapsed_hour} -gt ${2:-10} ]]; then
                            printf "${elapsed_hour} hours passed - $(printf ${status} | jq -cr)\n"
                            case "${1}" in
                                "stop-old")
                                    printf "Stop ${jobid}\n"
                                    rclone_rc_job_stop ${jobid}
                                    ;;
                            esac
                        fi
                        ;;
                    *) printf "${status}\n" ;;
                esac
                ;;
            *) printf "${status}\n" ;;
        esac
    done < <(rclone_rc_job_list | jq ".jobids[]")
}

rclone_servcie_container_restart(){
    # 도커 시작전에 도커 명령어를 실행하면 먹통
    # Path 유닛의 PathModified로 트리거를 설정 후 After=docker.service로 설정한 서비스를 실행
    # 1. rclonre.remote.serivce가 신호용 파일을 변경
    # 2. rclone.container.restart.path에서 신호용 파일의 변경을 감지하고 rclone.container.restart.service를 실행
    # 3. rclone.container.restart.service는 After=docker.service 설정에 따라 도커 서비스가 온라인 되면 실행
    case "${1}" in
        "mark")
            /usr/bin/touch /tmp/rclone.remote.ready
            ;;
        "restart")
            for container in ${RCLONE_RESTART_CONTAINERS}; do
                if docker inspect -f '{{.State.Running}}' "$container" &> /dev/null; then
                    log I "Restart container: ${container}"
                    docker restart "${container}"
                fi
            done
            ;;
    esac
}

rclone_service_start_post(){
    log I "Start post..."
    max_counter=60
    for counter in $(seq 1 ${max_counter}); do
        if rclone_exec "$(rclone_flags_rc "rc/noop")" 2>&1 >/dev/null ; then
            log D "Rclone RC server is ready..."
            for mount in ${RCLONE_MOUNTS}; do
                log I "${mount}"
                rclone_rc_mount "${mount%%:*}:" "${mount##*:}"
            done
            break
        else
            log D "Rclone RC server is not ready..."
            sleep 1
        fi
    done
    rclone_servcie_container_restart mark
}

rclone_service_stop_post(){
    log I "Stop post..."
    for mount in ${RCLONE_MOUNTS}; do
        umount -vl "${mount##*:}"
    done
}

rclone_rcd(){
    log I "Rclone Remote Control daemon starts..."
    rclone_exec "${RCLONE_FLAGS_RCD[@]}"
}

rclone_backup_archive(){
    local target_profile="${1}"
    local archive_file_path="${2}"
    local files=("${@:3}")

    log I "아카이브 파일 생성: ${archive_file_path}"
    tar --ignore-failed-read -czvf "${archive_file_path}" "${files[@]}" 2>&1 \
    | while IFS= read -r line; do log D "${line}"; done

    local tar_exit=${PIPESTATUS[0]}
    if [[ ${tar_exit} -ne 0 ]]; then
        log E "아카이브 생성 실패: ${archive_file_path}"
        return 1
    fi
    return ${tar_exit}
}

rclone_backup_upload(){
    local target_profile="${1}"
    local archive_file_path="${2}"
    local remote_target_path="${3}"
    local archive_file_name="${archive_file_path##*/}"

    # 업로드
    log I "업로드: ${remote_target_path}${archive_file_name}"
    local flags=("move" "${archive_file_path}" "${remote_target_path}" ${RCLONE_BACKUP_FLAGS[@]})
    local result=$(rclone_exec "$(printf "%s\n" "${flags[@]}")")
    return_code=${?}
    log D "업로드 결과: ${return_code}"
    if [[ ${return_code} -ne 0 ]]; then
        log E "업로드 실패, 로컬에 파일이 남아있을 수도 있습니다: ${archive_file_path}"
        return 1
    fi
    return ${return_code}
}

rclone_backup_rotation_remote(){
    local rotation="${1}"
    local remote_target_path="${2}"

    flags=(lsf "${remote_target_path}" --files-only "--format=pt")
    result=$(rclone_exec "$(printf "%s\n" "${flags[@]}")")

    # rclone-backup-archive-20251021-005451.tar.gz;2025-10-21 00:55:06
    mapfile -t file_lines <<< "${result}"
    IFS=$'\n' sorted=($(printf "%s\n" "${file_lines[@]}" | sort -t ';' -k2))
    local count=${#sorted[@]}
    if (( count > rotation )); then
        log I "원격지 오래된 파일 정리 (총 ${count}개 중 ${rotation}개 유지)"
        local to_be_deleted=("${sorted[@]:0:count-rotation}")
        for line in "${to_be_deleted[@]}"; do
            # ';' 기준으로 파일명 추출
            file_to_be_deleted="${line%%;*}"
            log D "삭제: ${file_to_be_deleted}"
            flags=(deletefile "${remote_target_path}${file_to_be_deleted}")
            result=$(rclone_exec "$(printf "%s\n" "${flags[@]}")")
            [[ $? -ne 0 ]] && log E "삭제 실패: ${file_to_be_deleted}"
        done
    fi
}

rclone_backup_rotation() {
    local rotation="${1}"
    shift
    local files=()

    for file in "${@}"; do
        [[ -f "${file}" ]] && files+=("${file}")
    done

    (( ${#files[@]} == 0 )) && {
        log W "대상 파일 없음"
        return
    }

    mapfile -t sorted < <(printf "%s\n" "${files[@]}" | xargs -n1 stat --format '%Y %n' | sort -n | awk '{print $2}')

    local count=${#sorted[@]}
    if (( count > rotation )); then
        local to_be_deleted=("${sorted[@]:0:count-rotation}")
        for file_to_be_deleted in "${to_be_deleted[@]}"; do
            log D "삭제: ${file_to_be_deleted}"
            rm -f "${file_to_be_deleted}"
            [[ $? -ne 0 ]] && log E "삭제 실패: ${file_to_be_deleted}"
        done
    fi
}

rclone_backup_script(){
    local script_name="${1}"
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        log I "실행: ${line}"
        if ! eval "${line}"; then
            log E "명령 실패: ${line}"
        fi
    done <<< "${!script_name}"
}

rclone_backup(){
    if [[ -z "${1}" ]]; then
        log E "백업 대상을 지정하세요."
        return 1
    fi

    local target_profile="${1}"

    log I "백업 시작 프로필: ${target_profile}"
    local backup_list_files=()
    for list_file in ${RCLONE_BACKUP_LIST_DIR}/*; do
        IFS='|' read -r -a parsed <<< "$(parse_filename "${list_file}")"
        if [[ "${parsed[2]}" == "${RCLONE_BACKUP_LIST_FILE_EXT}" ]] && [[ "${parsed[1]}" == ${RCLONE_BACKUP_LIST_FILE_PREFIX}* ]]; then
            local list_file_profile=${parsed[1]#${RCLONE_BACKUP_LIST_FILE_PREFIX}}
            if [[ "${target_profile}" == "${list_file_profile}" ]]; then
                backup_list_files+=("${list_file}")
            fi
        fi
    done
    if [[ ${#backup_list_files[@]} -eq 0 ]]; then
        log E "이 경로에서 백업 대상 목록을 찾지 못했습니다: ${RCLONE_BACKUP_LIST_DIR}"
        return 1
    fi

    if [[ ! -d "${RCLONE_BACKUP_TEMP_DIR}" ]]; then
        log I "임시 디렉토리 생성: ${RCLONE_BACKUP_TEMP_DIR}"
        mkdir -p "${RCLONE_BACKUP_TEMP_DIR}"
    fi

    for list_file in "${backup_list_files[@]}"; do
        log D "백업 대상 목록 파일:  ${target}"
        local timestamp=$(date +%Y%m%d-%H%M%S)
        local archive_file_name="${RCLONE_BACKUP_ARCHIVE_FILE_PREFIX}${target_profile}-${timestamp}.tar.gz"
        local archive_file_path="${RCLONE_BACKUP_TEMP_DIR}/${archive_file_name}"
        local remote_target_path="${RCLONE_BACKUP_REMOTE_PATH}/${target_profile}/"

        shopt -s nullglob
        files_to_archive=()
        while IFS= read -r line || [[ -n "${line}" ]]; do
            line="${line//$'\r'/}"
            if [[ -z "${line}" || "${line}" =~ ^\s*# ]]; then
                continue
            fi
            dir_part="${line%/*}"
            file_pattern="${line##*/}"
            if [[ "${dir_part}" == "${file_pattern}" ]]; then
                dir_part="."
            fi
            while IFS= read -d '' -r found_file; do
                files_to_archive+=("${found_file}")
            done < <(find "${dir_part}" -maxdepth 1 -name "${file_pattern}" -print0 2>/dev/null)
        done < "${list_file}"
        shopt -u nullglob

        rclone_backup_archive "${target_profile}" "${archive_file_path}" "${files_to_archive[@]}"
        if [[ ${?} -ne 0 ]]; then
            continue
        fi
        rclone_backup_upload "${target_profile}" "${archive_file_path}" "${remote_target_path}"
        rclone_backup_rotation_remote ${RCLONE_BACKUP_ROTATION_REMOTE:-3} "${remote_target_path}"
        log I "작업을 완료했습니다: ${target_profile}"
    done
}

rclone_manager(){
    case "${1}" in
        "metadata")
            shift 1
            result="$(rclone_rc_vfs_stats ${1})"
            log I "Rclone metadata in memory : $(printf "${result}" | jq -c '.metadataCache')"
            printf "%s" "${result}" | jq -c '.metadataCache'
            ;;
        "refresh")
            shift 1
            remote="${1}"
            flags="$(rclone_flags_rc_vfs_refresh "${remote}" "${@}")"
            rclone_exec "$flags"
            ;;
        "refresh-all")
            shift 1
            flags="$(rclone_flags_rc_vfs_refresh ${1})"
            flags+=$'\n'"async=true"
            rclone_exec "${flags[@]}"
            ;;
        "jobs")
            rclone_print_json "$(rclone_rc_job_list)"
            ;;
        "jobs-detailed")
            rclone_print_json "$(rclone_rc_job_list_detailed)"
            ;;
        "jobs-not-finished")
            rclone_print_json "$(rclone_rc_job_list_detailed not-finished)"
            ;;
        "jobs-not-finished-old")
            shift 1
            rclone_rc_job_list_detailed not-finished-old ${1}
            ;;
        "jobs-stop-old")
            shift 1
            rclone_rc_job_list_detailed stop-old ${1}
            ;;
        "jobs-status")
            shift 1
            rclone_print_json "$(rclone_rc_job_status ${1})"
            ;;
        "rc")
            shift 1
            rclone_exec "$(rclone_flags_rc "${@}")"
            ;;
        "rc-mount")
            shift 1
            rclone_rc_mount "${1}" "${2}"
            ;;
        "rc-unmount")
            shift 1
            rclone_rc_unmount "${1}"
            ;;
        "rc-unmount-all")
            rclone_rc_unmount all
            ;;
        "rc-log-level")
            shift 1
            rclone_exec "$(rclone_flags_rc options/set --json "{\"main\": {\"LogLevel\": ${1}}}")"
            ;;
        "stats")
            rclone_exec "$(rclone_flags_rc core/stats)"
            ;;
        "backup")
            shift 1
            case "${1}" in
                "ssh")
                    last -f /var/log/btmp | tee ${LOG_DIR}/ssh.failed.log
                    last -f /var/log/wtmp | tee ${LOG_DIR}/ssh.success.log
                    ;;
                "rotate")
                    shift 1
                    rclone_backup_rotation "${@}"
                    ;;
                *)
                    "${1}"
                    local pre_script="RCLONE_BACKUP_PRE_SCRIPT_${1^^}"
                    local post_script="RCLONE_BACKUP_POST_SCRIPT_${1^^}"
                    if [[ -n "${!pre_script}" ]]; then
                        rclone_backup_script ${pre_script}
                    fi
                    rclone_backup "${1}"
                    if [[ -n "${!post_script}" ]]; then
                        rclone_backup_script ${post_script}
                    fi
                    ;;
            esac
            ;;
        "rc-start-post")
            # aider.sh rclone start-post
            rclone_service_start_post
            ;;
        "rc-stop-post")
            # aider.sh rclone stop-post
            rclone_service_stop_post
            ;;
        "rcd")
            # aider.sh rclone rcd
            rclone_rcd
            ;;
        "restart-container")
            rclone_servcie_container_restart restart
            ;;
        "fscache")
            # This clears the fs cache. This is where remotes created from backends are cached for a short while to make repeated rc calls more efficient.
            # If you change the parameters of a backend then you may want to call this to clear an existing remote out of the cache before re-creating it.
            rclone_exec "$(rclone_flags_rc fscache/clear)"
            ;;
        *)
            # aider.sh rclone lsd remote:
            rclone_exec "$(printf "%s\n" "${@}")"
            ;;
    esac
}

#!/usr/bin/env bash

plex_get_section_by_dir(){
    local sections path
    sections=$(curl -H "accept: application/json" "${PLEX_URL}/library/sections/?X-Plex-Token=${PLEX_TOKEN}")
    while read path; do
        [[ "${1}" =~ ${path} ]] && break
    done < <(echo ${sections} | jq -r .MediaContainer.Directory[].Location[].path)
    echo ${sections} | jq -r ".MediaContainer.Directory[] | select(.Location[].path==\"${path}\") | .key"

}

plex_scan(){
    local target_dir section
    [[ -e "${1}" ]] || {
        log E "존재하지 않는 경로 : ${1}"
        return 1
    }

    target_dir="${1}"
    [[ -f "${1}" ]] && target_dir=$(dirname "${1}")
    log D "스캔할 경로 : ${target_dir}"

    section=$(plex_get_section_by_dir "${target_dir}")
    [[ ${section} ]] || {
        log E "section 번호를 찾을 수 없음 : ${target_dir}"
        return 1
    }

    # bash에서 사용하는 특수문자(예: [] ...)가 url에 포함되어 오류 발생할 경우 --globoff
    curl -G --globoff "${PLEX_URL}/library/sections/${section}/refresh" \
        --data-urlencode "path=${target_dir}" \
        -d "X-Plex-Token=${PLEX_TOKEN}"
}

plex_clean_cache(){
    local photo_transcoder="${PLEX_MEDIA_SERVER_APPLICATION_SUPPORT_DIR}/Plex Media Server/Cache/PhotoTranscoder"
    echo
    rm -rfv "${photo_transcoder}"/**
}

plex_ramdisk(){
    for pair in "${PLEX_RAM_BACKUP_LINK_PAIRS[@]}"; do
        IFS="|" read -r -a dirs <<< "${pair}"
        plex_db_ram="${dirs[0]}/${PLEX_DB_FILE}"
        plex_db_backup="${dirs[1]}/${PLEX_DB_FILE}"
        plex_db_link="${dirs[2]}/${PLEX_DB_FILE}"
        if [[ -e "${plex_db_ram}" ]]; then
            # 램디스크에 파일이 있으면 백업
            [[ ! -e "${dirs[1]}" ]] && mkdir -vp "${dirs[1]}"
            cp -vrf "${plex_db_ram}" "${plex_db_backup}"
            log I "DB 백업 완료: ${plex_db_ram}"
        else
            # 램디스크에 파일이 없으면 백업에서 복사
            if [[ ! -e "${plex_db_backup}" ]]; then
                log E "파일 없음: ${plex_db_backup}"
                continue
            fi
            [[ ! -e "${dirs[0]}" ]] && mkdir -vp "${dirs[0]}"
            cp "${plex_db_backup}" "${plex_db_ram}"
            chown -R plex:plex "${dirs[0]}"
            log I "DB 복사 완료: ${plex_db_ram}"
        fi
        check_link "${dirs[2]}"
    done
}

plex_backup(){
    README="""
    ~/backup/plex/Databases
        /com.plexapp.plugins.library.db-2025-03-08
        /com.plexapp.plugins.library.db-2025-03-11
        /com.plexapp.plugins.library.db.0.gz
        /com.plexapp.plugins.library.db.1.gz
    """
    for backup_dir in "${PLEX_DB_BACKUPS[@]}"; do
        backup_targets=("${backup_dir}"/com.plexapp.plugins.library.db-*)
        IFS=$'\n' sorted=($(sort -r <<<"${backup_targets[*]}"))
        unset IFS
        for idx in $( seq 0 $((${#sorted[@]} - 1)) ); do
            [[ ! -f "${sorted[$idx]}" ]] && continue
            if [[ ${idx} -gt 1 ]]; then
                echo "rm: ${sorted[$idx]}"
                rm -f "${sorted[$idx]}"
                continue
            fi
            cd ${backup_dir}
            echo "tar: ${PLEX_DB_FILE}.${idx}.tar.gz < ${sorted[$idx]}"
            tar -zcvf "${PLEX_DB_FILE}.${idx}.tar.gz" "$(basename "${sorted[$idx]}")"
        done
    done
}

plex_manager(){
    case "${1}" in
        "scan")
            shift 1
            plex_scan "${*}"
            ;;
        "restart")
            ${PLEX_LAUNCHER} stop
            ${PLEX_LAUNCHER} start
            ;;
        "status")
            ${PLEX_LAUNCHER} status
            ;;
        "clean")
            plex_clean_cache
            ;;
        "ramdisk")
            plex_ramdisk
            ;;
        "backup")
            plex_backup
            ;;
    esac
}
